nom <- fxext_layer_complete_nominate(fxGeom("Discrete"), AesName("y"),
data.frame())
purrr::walk(nom, ~ expect_true(is_nomination(.)))
})
nom <- fxext_layer_complete_nominate(fxGeom("Continuous"), AesName("x"),
data.frame())
covr::report()
fx_ggplot(diamonds, aes(x = x, y = y, color = color))
nrow(diamonds)
?agostino.test
agostino.test(c(rep(1, 10), NA_real_))
?sample
x <- diamonds[[x]]
x <- diamonds[["x"]]
x
if(length(x) > 46340)
x <- sample(x, size = 46340)
length(x)
agostino.test(x)
library(tectr)
library(tectr)
fx_ggplot(diamonds, aes(x = x, y = y, color = color))
agostino.test(diamonds$x)
library(geoR)
boxcoxfit(diamonds$x)
boxcoxfit(diamonds$x, lambda2 = TRUE)
boxcoxfit(diamonds$y, lambda2 = TRUE)
boxcoxfit(diamonds$color, lambda2 = TRUE)
fx_ggplot(diamonds, aes(x = x, y = y, color = color))
diamonds %>% fx_default(columns = "fxGeom_class") %>% select(x, y, z) %>% fx_info("stats", statistics = list(Boxcox = function(x, ...) boxcoxfit(x, lambda2 = TRUE)))
diamonds %>% fx_default(columns = "fxGeom_class") %>% dplyr::select(x, y, z) %>% fx_info("stats", statistics = list(Boxcox = function(x, ...) boxcoxfit(x, lambda2 = TRUE)))
diamonds %>% fx_default(columns = "fxGeom_class") %>% dplyr::select(x, y, z) %>% fx_info("stats", statistics = list(Boxcox = function(x, ...) boxcoxfit(x, lambda2 = TRUE)$lambda))
names(diamonds)
diamonds %>% fx_default(columns = "fxGeom_class") %>% dplyr::select(x, y, z, carat) %>% fx_info("stats", statistics = list(Boxcox = function(x, ...) boxcoxfit(x, lambda2 = TRUE)$lambda))
diamonds %>% fx_default(columns = "fxGeom_class") %>% dplyr::select(x, y, z, carat, price, table, depth) %>% fx_info("stats", statistics = list(Boxcox = function(x, ...) boxcoxfit(x, lambda2 = TRUE)$lambda))
diamonds %>% fx_default(columns = "fxGeom_class") %>% dplyr::select(depth) %>% fx_info("stats", statistics = list(Boxcox = function(x, ...) boxcoxfit(x, lambda2 = TRUE)$lambda))
diamonds %>% fx_default(columns = "fxGeom_class") %>% dplyr::select(table) %>% fx_info("stats", statistics = list(Boxcox = function(x, ...) boxcoxfit(x, lambda2 = TRUE)$lambda))
diamonds$table
hist(diamonds$table)
skewness(diamonds$table)
agostino.test(diamonds$table)
agostino.test(diamonds$table[1:46340])
boxcoxfit(diamonds$table[1:46340])
boxcoxfit(diamonds$table[1:46340], lambda2 = TRUE)
boxcoxfit(diamonds$table[1:500000], lambda2 = TRUE)
boxcoxfit(diamonds$table[1:50000], lambda2 = TRUE)
boxcoxfit
geoR:::.negloglik.boxcox
?try
?tryCatch
has_metaframe
library(tectr)
diamonds %>% fx_default(columns = "fxGeom_class") %>% dplyr::select(x, y, z, carat, price, table, depth) %>% fx_info("stats", statistics = list(Boxcox = function(x, ...) boxcoxfit(x, lambda2 = TRUE)$lambda))
fx_ggplot(diamonds, aes(x = x, y = y, color = color))
fx_ggplot(diamonds, aes(x = x, y = y, color = color), fxGeom_trans_simple = TRUE)
data <- fx_infer(diamonds)
data <- fx_default(diamonds)
data
mf <- metaframe(data)
mf
ret <- purrr::map_chr(
seq_len(nrow(mf)),
function(i) {
nam <- mf$name[i]
if(!is.numeric(data[[nam]]) | any(data[[nam]] <= 0, na.rm = TRUE))
return("identity")
ident <- data[[nam]]
sqrt <- sqrt(ident)
log <- log10(ident)
winner <- which.min(abs(c(
moments::skewness(ident, na.rm = TRUE),
moments::skewness(sqrt, na.rm = TRUE),
moments::skewness(log, na.rm = TRUE)
)))
return(c("identity", "sqrt", "log10")[winner])
}
)
ret
if(!fxGeom_trans_simple) {
ret <- purrr::map(
seq_len(nrow(mf)),
function(i) {
nam <- mf$name[i]
if(!is.numeric(data[[nam]])) return("identity")
x <- data[[nam]] %>% na.omit()
# The test can only work with a maximal n of 46340. Random sampling should
# take care of it.
if(length(x) > 46340)
x <- sample(x, size = 46340)
test <- moments::agostino.test(x)
if(test$p.value >= fxGeom_trans_p.threshold)
return("identity")
# boxcoxfit sometimes fails. In this case, we use the simple version.
bc <- tryCatch(
geoR::boxcoxfit(data[[nam]], lambda2 = TRUE),
error = function(e) return(ret[[i]])
)
lambda <- bc$lambda[1]
offset <- bc$lambda[2]
scales::boxcox_trans(p = lambda, offset = offset)
}
)
}
ret <- purrr::map(
seq_len(nrow(mf)),
function(i) {
nam <- mf$name[i]
if(!is.numeric(data[[nam]])) return("identity")
x <- data[[nam]] %>% na.omit()
# The test can only work with a maximal n of 46340. Random sampling should
# take care of it.
if(length(x) > 46340)
x <- sample(x, size = 46340)
test <- moments::agostino.test(x)
if(test$p.value >= fxGeom_trans_p.threshold)
return("identity")
# boxcoxfit sometimes fails. In this case, we use the simple version.
bc <- tryCatch(
geoR::boxcoxfit(data[[nam]], lambda2 = TRUE),
error = function(e) return(ret[[i]])
)
lambda <- bc$lambda[1]
offset <- bc$lambda[2]
scales::boxcox_trans(p = lambda, offset = offset)
}
)
fxGeom_trans_p.threshold <- .01
ret <- purrr::map(
seq_len(nrow(mf)),
function(i) {
nam <- mf$name[i]
if(!is.numeric(data[[nam]])) return("identity")
x <- data[[nam]] %>% na.omit()
# The test can only work with a maximal n of 46340. Random sampling should
# take care of it.
if(length(x) > 46340)
x <- sample(x, size = 46340)
test <- moments::agostino.test(x)
if(test$p.value >= fxGeom_trans_p.threshold)
return("identity")
# boxcoxfit sometimes fails. In this case, we use the simple version.
bc <- tryCatch(
geoR::boxcoxfit(data[[nam]], lambda2 = TRUE),
error = function(e) return(ret[[i]])
)
lambda <- bc$lambda[1]
offset <- bc$lambda[2]
scales::boxcox_trans(p = lambda, offset = offset)
}
)
i <- 1
nam <- mf$name[i]
nam
if(!is.numeric(data[[nam]])) return("identity")
x <- data[[nam]] %>% na.omit()
x
# The test can only work with a maximal n of 46340. Random sampling should
# take care of it.
if(length(x) > 46340)
x <- sample(x, size = 46340)
test <- moments::agostino.test(x)
test
if(test$p.value >= fxGeom_trans_p.threshold)
return("identity")
# boxcoxfit sometimes fails. In this case, we use the simple version.
bc <- tryCatch(
geoR::boxcoxfit(data[[nam]], lambda2 = TRUE),
error = function(e) return(ret[[i]])
)
bc
lambda <- bc$lambda[1]
offset <- bc$lambda[2]
scales::boxcox_trans(p = lambda, offset = offset)
i <- 2
nam <- mf$name[i]
nam
mf$name
i <- 6
nam <- mf$name[i]
if(!is.numeric(data[[nam]])) return("identity")
x <- data[[nam]] %>% na.omit()
# The test can only work with a maximal n of 46340. Random sampling should
# take care of it.
if(length(x) > 46340)
x <- sample(x, size = 46340)
test <- moments::agostino.test(x)
if(test$p.value >= fxGeom_trans_p.threshold)
return("identity")
# boxcoxfit sometimes fails. In this case, we use the simple version.
bc <- tryCatch(
geoR::boxcoxfit(data[[nam]], lambda2 = TRUE),
error = function(e) return(ret[[i]])
)
bc
fx_ggplot(diamonds, aes(x = x, y = y, color = color))
fx_ggplot(diamonds, aes(x = x, y = y, color = color))
library(tectr)
fx_ggplot(diamonds, aes(x = x, y = y, color = color))
traceback()
scale_x_continuous
fx_ggplot(diamonds, aes(x = x, y = y, color = color))
?scale_x_discrete
scale_x_discrete
scale_color_discrete
discrete_scale
hue_pal
hue_pal()
scale_alpha_discrete
scale_size_discrete
scale_shape_discrete
shape_pal
?AesName
fx_ggplot(mtcars, aes(x = mpg))
?discrete_scale
fx_ggplot(mtcars, aes(x = mpg))
data <- mtcars
data <- fx_default(data, columns = fx_ggplot_columns) %>%
fx_evaluate()
data
layers <- c(
# At first, we add the geometric information along one dimension
purrr::map(names(mapping), ~ fxi_layer_single(data, mapping, .)) %>%
unlist(recursive = FALSE),
# Then, we add the geometric information that is dependent on all dimensions
fxi_layer_complete(data, mapping)
)
mapping <- aes(x= mpg)
layers <- c(
# At first, we add the geometric information along one dimension
purrr::map(names(mapping), ~ fxi_layer_single(data, mapping, .)) %>%
unlist(recursive = FALSE),
# Then, we add the geometric information that is dependent on all dimensions
fxi_layer_complete(data, mapping)
)
layers <- c(
# At first, we add the geometric information along one dimension
purrr::map(names(mapping), ~ tectr:::fxi_layer_single(data, mapping, .)) %>%
unlist(recursive = FALSE),
# Then, we add the geometric information that is dependent on all dimensions
tectr:::fxi_layer_complete(data, mapping)
)
layers
nam <- "x"
mf <- metaframe(data) %>%
dplyr::filter(name == as.character(rlang::quo_get_expr(mapping[[nam]])))
mf
mf$fxGeom_trans
assertthat::assert_that(nrow(mf) == 1, "fxGeom_class" %in% colnames(mf))
fx_geom <- fxGeom(mf[["fxGeom_class"]])
aes_name <- AesName(nam)
mf <- lst_mf_args(mf)
do.call(
fxe_layer_single,
rlang::list2(fx_geom, aes_name, data = data, rlang::splice(mf))
)
fx_geom
aes_name
fxe_layer_other
fxGeom_breaks = NULL
fxGeom_minor_breaks = NULL
fxGeom_labels = NULL
ggplot(mtcars, aes(x=mpg)) + layers
ggplot(mtcars, aes(x=mpg)) + layers[c(1,3)]
scale_x_discrete
geom_bar
?geom_bar
scale_x_continuous
scale_y_continuous
fx_ggplot(mtcars, aes(x = mpg))
ggplot(mtcars, aes(x = mpg)) + geom_histogram() -> p
p + discrete_scale("x", "", fxe_default_fxGeom_pal(fxGeom("Continuous"), AesName("x")))
p + continuous_scale("x", "", fxe_default_fxGeom_pal(fxGeom("Continuous"), AesName("x")))
p
p + continuous_scale(c("x", "xmin", "xmax", "xend", "xintercept",
"xmin_final", "xmax_final", "xlower", "xmiddle", "xupper"), "", fxe_default_fxGeom_pal(fxGeom("Continuous"), AesName("x"))))
p + continuous_scale(c("x", "xmin", "xmax", "xend", "xintercept",
"xmin_final", "xmax_final", "xlower", "xmiddle", "xupper"), "", fxe_default_fxGeom_pal(fxGeom("Continuous"), AesName("x")))
p + scale_x_discrete()
p
p + scale_x_discrete(breaks = waiver())
p + scale_x_continuous()
scale_x_discrete
scale_x_continuous
fx_ggplot(diamonds, aes(x = color))
p + continuous_scale("x", "", fxe_default_fxGeom_pal(fxGeom("Continuous"), AesName("x"))))
p + continuous_scale("x", "", fxe_default_fxGeom_pal(fxGeom("Continuous"), AesName("x")))
scale_x_discrete
p + continuous_scale("x", "position_d", fxe_default_fxGeom_pal(fxGeom("Continuous"), AesName("x")))
p
p + continuous_scale("x", "position_d", fxe_default_fxGeom_pal(fxGeom("Continuous"), AesName("x")))
p
scale_x_continuous
p + continuous_scale("x", "position_c", fxe_default_fxGeom_pal(fxGeom("Continuous"), AesName("x")))
p + continuous_scale("y", "position_c", fxe_default_fxGeom_pal(fxGeom("Continuous"), AesName("x")))
p + continuous_scale("y", "position_c", fxe_default_fxGeom_pal(fxGeom("Continuous"), AesName("x"))) + continuous_scale("y", "position_c", fxe_default_fxGeom_pal(fxGeom("Continuous"), AesName("x")))
p + continuous_scale("y", "position_c", fxe_default_fxGeom_pal(fxGeom("Continuous"), AesName("x"))) + continuous_scale("x", "position_c", fxe_default_fxGeom_pal(fxGeom("Continuous"), AesName("x")))
fxe_default_fxGeom_pal(fxGeom("Continuous"), AesName("x"))
p + continuous_scale("y", "position_c", fxe_default_fxGeom_pal(fxGeom("Continuous"), AesName("x"))) + continuous_scale("x", "position_c", fxe_default_fxGeom_pal(fxGeom("Continuous"), AesName("x")))
p
p + continuous_scale("x", "position_c", fxe_default_fxGeom_pal(fxGeom("Continuous"), AesName("x"))) + continuous_scale("y", "position_c", fxe_default_fxGeom_pal(fxGeom("Continuous"), AesName("x")))
scale_x_continuous
sc <- continuous_scale(c("x", "xmin", "xmax", "xend", "xintercept",
"xmin_final", "xmax_final", "xlower", "xmiddle", "xupper"),
"position_c", identity)
sc
p + sc
p
ggplot(mtcars, aes(x = mpg)) + scale_x_continuous
ggplot(mtcars, aes(x = mpg)) + scale_x_continuous()
ggplot(mtcars, aes(x = mpg)) + scale_x_continuous() + geom_histogram()
ggplot(mtcars, aes(x = mpg)) + continuous_scale("x", "", identity) + geom_histogram()
scale_y_continuous
ggplot(mtcars, aes(x = mpg)) + continuous_scale("x", "", identity) + continuous_scale(c("y", "ymin", "ymax", "yend", "yintercept",
"ymin_final", "ymax_final", "lower", "middle", "upper"), "", identity) + geom_histogram()
p
ggplot(mtcars, aes(x = mpg)) + continuous_scale("x", "", identity) + continuous_scale(c("y", "ymin", "ymax", "yend", "yintercept",
"ymin_final", "ymax_final", "lower", "middle", "upper"), "", identity) + geom_histogram()
?scale_x_continuous
p
p + scale_x_continuous(palette = identity)
?scale_colour_continuous
scale_x_continuous
?is.waive
is.waive(waiver())
ggplot2:::is.waive(waiver())
scale_colour_continuous() -> sc
sc$palette
p
ggplot(diamonds, aes(x = color, color = color)) + geom_bar() -> p
p + sc
scale_colour_discrete() -> sc
sc
p + sc
sc$palette.cache
sc$palette <- scales::brewer_pal()
p + sc
?scale_colour_continuous
Scale
rm(list = ls())
fx_ggplot(mtcars, aes(x = mpg))
fx_ggplot(mtcars, aes(x = mpg))
fx_ggplot(diamonds, aes(x = x, y = y))
fx_ggplot(diamonds, aes(x = x, y = y))
fx_ggplot(mtcars, aes(x = color))
fx_default(mtcars, columns = fx_ggplot_columns) -> data
data
metaframe(data)
metaframe(data) %>% dplyr::as_tibble()
fx_default(diamonds, columns = fx_ggplot_columns) -> data
metaframe(data)
metaframe(data) %>% dplyr::as_tibble()
fx_ggplot(mtcars, aes(x = color))
?get_inds
fx_ggplot(diamonds, aes(x = color))
?scale_x_dscrete
fx_ggplot(diamonds, aes(x = color))
fx_ggplot(diamonds, aes(x = color, fill = cut))
fx_ggplot(diamonds, aes(x = x, y = y))
traceback()
fx_ggplot(diamonds, aes(x = x))
data <- diamonds
mf <- metaframe(data) %>%
dplyr::filter(name == as.character(rlang::quo_get_expr(mapping[[nam]])))
data <- fx_default(data, columns = fx_ggplot_columns, ...) %>%
fx_evaluate()
data <- fx_default(data, columns = fx_ggplot_columns) %>%
fx_evaluate()
data
metaframe(data)
metaframe(data)$fxGeom_trans[[8]]
metaframe(data)$fxGeom_trans[[9]]
metaframe(data)$fxGeom_trans[[10]]
metaframe(data)$fxGeom_trans[[1]]
fx_ggplot(diamonds, aes(x = carat))
fx_ggplot(diamonds, aes(x = y))
fx_ggplot(diamonds, aes(x = z))
metaframe(data)$fxGeom_limits[[8]]
fx_ggplot(diamonds, aes(x = z), fxGeom_trans_simple = TRUE)
covr::report()
tst <- filter_req_aes(
nominations = list(geom_point(), geom_bar()),
mapping = aes(x = x)
)
tst <- tectr:::filter_req_aes(
nominations = list(geom_point(), geom_bar()),
mapping = aes(x = x)
)
tst
nominations = list(geom_point(), geom_bar())
has_req_aes <- purrr::map_lgl(
nominations,
function(nom) all(c(names(mapping), nom$mapping) %in% required_aes(nom))
)
mapping <- aes(x =x)
has_req_aes <- purrr::map_lgl(
nominations,
function(nom) all(c(names(mapping), nom$mapping) %in% required_aes(nom))
)
has_req_aes <- purrr::map_lgl(
nominations,
function(nom) all(c(names(mapping), nom$mapping) %in% tectr:::required_aes(nom))
)
has_req_aes
c(names(mapping))
nominations[[1]] -> nom
c(names(mapping), nom$mapping)
tectr:::required_aes(nom)
tectr:::required_aes(nom)
test_that("filter_req_aes", {
tst <- filter_req_aes(
nominations = list(geom_point(), geom_bar()),
mapping = aes(x = x)
)
expect_equal(length(tst), 1)
expect_true(inherits(tst, "GeomBar"))
})
tst <- tectr:::filter_req_aes(
nominations = list(geom_point(), geom_bar()),
mapping = aes(x = x)
)
tst <- tectr:::filter_req_aes(
nominations = list(geom_point(), geom_bar()),
mapping = aes(x = x)
)
tst
tectr:::required_aes(geom_point())
geom_point()$mapping
tectr:::required_aes(geom_bar())
tectr:::required_aes(geom_histogram())
tectr:::required_aes(geom_boxplot())
geom_boxplot()$mapping
covr::report()
fx_default_fxGeom_pal(fxGeom("Continuous"), AesName("x"))
?fx_default_fxGeom_pal
expect_equal(fx_default_fxGeom_pal(data, aes_name = "x"),
scale_x_continuous())
expect_identical(fx_default_fxGeom_pal(data, aes_name = "x"),
scale_x_continuous())
sc1 <- fx_default_fxGeom_pal(data, aes_name = "x")
sc1
pal1 <- fx_default_fxGeom_pal(data, aes_name = "x")
pal1
data <- dplyr::tibble(col1 = 1:10, col2 = LETTERS[1:10])
pal1 <- fx_default_fxGeom_pal(data, aes_name = "x")
pal1
mf = metaframe(fx_default(data))
mf
pal1 <- fx_default_fxGeom_pal(data, aes_name = "x")
pal2
pal1
expect_equal(pal1, list(identity, identity))
pal1 <- fx_default_fxGeom_pal(data, aes_name = "fill")
pal1
?scale_size_discrete
scale_size_discrete
data <- dplyr::tibble(column_name = 1:10)
metaframe(data) <- dplyr::tibble(
name = "column_name",
fxGeom_pal.colour_fill = scales::brewer_pal()
)
metaframe(data) <- dplyr::tibble(
name = "column_name",
fxGeom_pal.colour_fill = list(scales::brewer_pal())
) %>% as_metaframe()
sca <- fxi_layer_single(data, metaframe(data), "column_name")
sca <- tectr:::fxi_layer_single(data, metaframe(data), "column_name")
sca <- fxi_layer_single(data, aes(x = column_name), "x")
sca <- tectr:::fxi_layer_single(data, aes(x = column_name), "x")
sca
data <- fx_default(data, columns = fx_ggplot_columns)
sca <- fxi_layer_single(data, aes(x = column_name), "x")
sca <- tectr:::fxi_layer_single(data, aes(x = column_name), "x")
sca
sca[[2]]$palette
sca[[2]]$palette %>% identical(brewer_pal())
sca[[2]]$palette(3)
sca[[2]]$palette(5)
sca <- fxi_layer_single(data, aes(fill = column_name), "fill")
sca <- tectr:::fxi_layer_single(data, aes(fill = column_name), "fill")
sca
sca$palette
sca[[2]]$palette
sca[[2]]$palette(5)
covr::report()
devtools::use_test("fx-fun-ggplot-fxGeomContinuous")
covr::report()
devtools::use_test("fx-fun-ggplot-fxGeomDiscrete")
covr::report()
?coverage
?covr::exclusions
covr::package_coverage()
covr::package_coverage()
?facet_grid
?facet_wrap
?facet_null
fx_ggplot(diamonds, aes(x = x, y = y, colour = color))
fx_ggplot(diamonds, aes(x = x, y = z, colour = color))
fx_ggplot(diamonds, aes(x = x, y = y, colour = color)) -> p
p + facet_wrap(vars(cut))
p + facet_wrap(vars(cut), scales = "free")
?facet_grid
p + facet_grid(vars(cut), vars(color))
?labeller
?facet_wrap
p + facet_wrap(vars(cut, color), scales = "free")
?facet_wrap
?facet_grid
p + facet_wrap(vars(cut))
p + facet_wrap(vars(cut), margins = TRUE)
?facet_wrap
?boxcox_trans
scales::boxcox_trans
